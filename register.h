//  COPY THE CONTENTS FROM https://docs.google.com/spreadsheets/d/1Spf1qlaAH2hzwa2MvuDNv2pzeSAhlU451IRfEV6stMI/edit?usp=sharing
//  Define the name and type of a register.  Also defines the list of registers used.
#ifndef REGISTER_H
#define REGISTER_H

#include <Arduino.h>
#include "Flash/src/Flash.h"
#include "unabiz-arduino-master/Akeru.h"
#include "modbus-types.h"

extern Akeru akeru;

struct Register {
  //  Every Modbus register is defined by these attributes.
  const boolean transmit;  //  True if this register should be transmitted to SIGFOX.
  const uint16_t address;  //  Address of register.
  const uint16_t size;     //  In 16-bit words.
  const uint16_t name_index;        //  Name of register, indexed to all_names.
  const uint16_t unit_index;        //  Unit e.g. "A / 1000", indexed to all_units.
  const uint16_t type;     //  Type of register from MODBUS_TYPES e.g. TYPE_U32.
};

const uint16_t max_register_size = 58;  //  Computed max number of words per field across all fields.
const Register OLD_all_registers[] = {  //  TODO: Move to Flash memory.
    //{ true, 50520, 2, "simple_voltage_v1", "V / 100", TYPE_U32 },
    //{ true, 50526, 2, "frequency_f", "Hz / 100", TYPE_U32 }
};

//  all_registers, all_names and all_units are generated by the spreadsheet above.
//  They are stored in read-only flash memory because dynamic memory is limited.

#ifndef PASTE_GENERATED_REGISTERS_HERE
//  Format: transmit, address, size, name_index, unit_index, type

FLASH_TABLE(uint16_t, all_registers, 6,  //  Generated list of registers based on Modbus table.
{ 1, 50520, 2, 3907, 53, 10 },  //  Simple voltage : V1 / V / 100
{ 0, 50512, 2, 1357, 36, 10 },  //  Hour Meter / h / 100
{ 0, 50514, 2, 2481, 53, 10 },  //  Phase to Phase Voltage: U12 / V / 100
{ 0, 50516, 2, 2509, 53, 10 },  //  Phase to Phase Voltage: U23 / V / 100
{ 0, 50518, 2, 2537, 53, 10 },  //  Phase to Phase Voltage: U31 / V / 100
{ 0, 50522, 2, 3927, 53, 10 },  //  Simple voltage : V2 / V / 100
{ 0, 50524, 2, 3947, 53, 10 },  //  Simple voltage : V3 / V / 100
{ 1, 50526, 2, 1264, 44, 10 },  //  Frequency : F / Hz / 100
{ 0, 50528, 2, 705, 25, 10 },  //  Current : I1 / A / 1000
{ 0, 50530, 2, 718, 25, 10 },  //  Current : I2 / A / 1000
{ 0, 50532, 2, 731, 25, 10 },  //  Current : I3 / A / 1000
{ 0, 50534, 2, 1920, 25, 10 },  //  Neutral Current : In / A / 1000
{ 0, 50536, 2, 75, 93, 4 },  //  Active Power +/- : P / W / 0.1
{ 0, 50538, 2, 3502, 70, 4 },  //  Reactive Power +/- : Q / var / 0.1
{ 0, 50540, 2, 395, 61, 10 },  //  Apparent Power : S / VA / 0.1
{ 0, 50542, 2, 2688, 0, 4 },  //  Power Factor : -: leading et + : lagging / - / 1000
{ 0, 50544, 2, 96, 93, 4 },  //  Active Power phase 1 +/- : P1 / W / 0.1
{ 0, 50546, 2, 126, 93, 4 },  //  Active Power phase 2 +/- : P2 / W / 0.1
{ 0, 50548, 2, 156, 93, 4 },  //  Active Power phase 3 +/- : P3 / W / 0.1
{ 0, 50550, 2, 3525, 70, 4 },  //  Reactive Power phase 1 +/- : Q1 / var / 0.1
{ 0, 50552, 2, 3557, 70, 4 },  //  Reactive Power phase 2 +/- : Q2 / var / 0.1
{ 0, 50554, 2, 3589, 70, 4 },  //  Reactive Power phase 3 +/- : Q3 / var / 0.1
{ 0, 50556, 2, 414, 61, 10 },  //  Apparent Power phase 1 : S1 / VA / 0.1
{ 0, 50558, 2, 442, 61, 10 },  //  Apparent Power phase 2 : S2 / VA / 0.1
{ 0, 50560, 2, 470, 61, 10 },  //  Apparent Power phase 3 : S3 / VA / 0.1
{ 0, 50562, 2, 2729, 0, 4 },  //  Power Factor phase 1 -: leading and + :  / - / 1000
{ 0, 50564, 2, 2852, 0, 4 },  //  Power Factor phase 2 -: leading and + :  / - / 1000
{ 0, 50566, 2, 2975, 0, 4 },  //  Power Factor phase 3 -: leading and + :  / - / 1000
);

#endif  //  PASTE_GENERATED_REGISTERS_HERE

#ifndef PASTE_GENERATED_NAMES_HERE

const uint16_t max_name_length = 40;
const char all_names[] PROGMEM =  //  Generated list of all register names based on Modbus table.
    "Action Calib\0"
        "Active Energy +\0"
        "Active Energy +<10 000\0"
        "Active Energy +>10 000\0"
        "Active Power +/- : P\0"
        "Active Power phase 1 +/- : P1\0"
        "Active Power phase 2 +/- : P2\0"
        "Active Power phase 3 +/- : P3\0"
        "Active Power phase1 +/-\0"
        "Active Power phase2 +/-\0"
        "Active Power phase3 +/-\0"
        "Alarm Hysteresis(0-99)\0"
        "Alarm Lower Threshold\0"
        "Alarm Specified time (1-999)\0"
        "Alarm Type :1 : I2 : In3 : U4 : V5 : P+6\0"
        "Alarm upper Threshold\0"
        "Apparent Power : S\0"
        "Apparent Power phase 1 : S1\0"
        "Apparent Power phase 2 : S2\0"
        "Apparent Power phase 3 : S3\0"
        "Apparent Power phase1\0"
        "Apparent Power phase2\0"
        "Apparent Power phase3\0"
        "Backligth Force\0"
        "Clr Relais Impulsion\0"
        "Code Constructeur\0"
        "Coef Gnrale Courant\0"
        "Coef Gnrale Puissance\0"
        "Coef Gnrale Tension\0"
        "Courant Inject en Calib\0"
        "Current : I1\0"
        "Current : I2\0"
        "Current : I3\0"
        "Current alarm on lower threshold : min v\0"
        "Current alarm on lower threshold cause:0\0"
        "Current alarm on upper threshold : max v\0"
        "Current alarm on upper threshold cause:0\0"
        "Current Transformer primary\0"
        "Current Transformer secondary : / 1 : 1 \0"
        "Current Transformer secondary : 1: 1 A 5\0"
        "Customisation specific data loaded0x0000\0"
        "Customization data loaded (True/False)\0"
        "Customization version (Major)\0"
        "Customization version (Minor)\0"
        "Customization VLO (EX : 880700)\0"
        "Diagnostique\0"
        "Dphasage Phase 1\0"
        "Dphasage Phase 2\0"
        "Dphasage Phase 3\0"
        "Frequency\0"
        "Frequency : F\0"
        "Frequency : Fr\0"
        "Gain I1\0"
        "Gain I2\0"
        "Gain I3\0"
        "Gain IN\0"
        "Gain V1\0"
        "Gain V2\0"
        "Gain V3\0"
        "Gain VN\0"
        "Hour Meter\0"
        "Hour Meter +<10000\0"
        "Hour Meter +>10000\0"
        "Hour meter allocation1 : Auxiliary power\0"
        "Hour meter trigger threshold\0"
        "I 1 AVG MAX\0"
        "I 2 AVG MAX\0"
        "I 3 AVG MAX\0"
        "In AVG MAX\0"
        "Input 1 state\0"
        "Input 2 state\0"
        "JBUS Address\0"
        "JBUS BaudRate\0"
        "JBUS Table Version (EX: 101 Version 1.01\0"
        "Key Tests\0"
        "max/avg active power +\0"
        "max/avg apparent power\0"
        "Max/avg I1\0"
        "Max/avg I2\0"
        "Max/avg I3\0"
        "Max/avg In\0"
        "Max/avg P+\0"
        "Max/avg Q+\0"
        "max/avg reactive power +\0"
        "Max/avg S\0"
        "N Srie ( AASS)\0"
        "N Srie ( Rserve)\0"
        "N Srie ( XXL)\0"
        "Network Type : / 0 : 1BL / 1 : 2BL / 2 :\0"
        "Network Type :0 : 1BL 1 : 2BL 2 : 3BL 3 \0"
        "Neutral Current\0"
        "Neutral Current : In\0"
        "Offset calibration ( 0 - 1024 )\0"
        "Offset I1\0"
        "Offset I2\0"
        "Offset I3\0"
        "Offset IN\0"
        "Offset Int/Ext ( default : 0 )\0"
        "Offset V1\0"
        "Offset V2\0"
        "Offset V3\0"
        "Offset VN\0"
        "Option Slot 10xFF : None0x0 : Metering o\0"
        "OUT : pulse output allocation :0 : kWh+1\0"
        "OUT : pulse output duration :1 : 100ms2 \0"
        "OUT : pulse output value :0 : 0,1 kWh/kv\0"
        "P+ AVG MAX\0"
        "Partial Positive Active Energy: Ea+\0"
        "Partial Positive Reactive Energy: Er +\0"
        "Phase 1 Current\0"
        "Phase 2 Current\0"
        "Phase 3 Current\0"
        "Phase to Neutral voltage phase 1\0"
        "Phase to Neutral voltage phase 2\0"
        "Phase to Neutral voltage phase 3\0"
        "Phase to Phase Voltage: U12\0"
        "Phase to Phase Voltage: U23\0"
        "Phase to Phase Voltage: U31\0"
        "Power factor : -: capacitif et + : induc\0"
        "power factor : -: leadiing et + : laggin\0"
        "power factor : -: leading and + : laggin\0"
        "Power Factor : -: leading et + : lagging\0"
        "Power Factor phase 1 -: leading and + : \0"
        "Power factor phase 1 -:leading and +: la\0"
        "Power factor phase 1-: leading and +: la\0"
        "Power Factor phase 2 -: leading and + : \0"
        "Power factor phase 2 -:leading and +: la\0"
        "Power factor phase 2-: leading and +: la\0"
        "Power Factor phase 3 -: leading and + : \0"
        "Power factor phase 3 -:leading and +: la\0"
        "Power factor phase 3-: leading and +: la\0"
        "Product build date\0"
        "Product ID (EX: 1000 ATS3)\0"
        "Product name (EX : DIRIS A40R)\0"
        "Product option code (bit field) :bit 1: \0"
        "Product order ID (Countis:100, Protectio\0"
        "Product software version (EX: 100 Versio\0"
        "Product version (Build)\0"
        "Product version (Major)\0"
        "Product version (Minor)\0"
        "Product version (Revision)\0"
        "Product VLO (EX : 880100)\0"
        "Q+ AVG MAX\0"
        "Reactive Energy +\0"
        "Reactive Energy +>10 000\0"
        "Reactive Energy+< 10 000\0"
        "Reactive Power +/- : Q\0"
        "Reactive Power phase 1 +/- : Q1\0"
        "Reactive Power phase 2 +/- : Q2\0"
        "Reactive Power phase 3 +/- : Q3\0"
        "Reactive Power phase1 +/-\0"
        "Reactive Power phase2 +/-\0"
        "Reactive Power phase3 +/-\0"
        "Relay State :0 : Normaly Open1 : Normaly\0"
        "Retrofit activated0x0000 : FALSE0x0001 :\0"
        "Rserv constructeur\0"
        "See Code table tab for more details\0"
        "Serial_AA_SS\0"
        "Serial_order\0"
        "Serial_Reserve\0"
        "Serial_SST_L\0"
        "Set Relais Impul\0"
        "Simple voltage : V1\0"
        "Simple voltage : V2\0"
        "Simple voltage : V3\0"
        "SOCO\0"
        "Software technical base version (Major)\0"
        "Software technical base version (Minor)\0"
        "Software technical base version (Revisio\0"
        "Software technical base VLO (EX : 880600\0"
        "Synchronisation of I AVG/MAX: Synchronis\0"
        "Synchronisation of I AVG/MAX:2 : 2 secon\0"
        "Synchronisation of P/Q/S AVG/MAX Synchro\0"
        "Synchronisation of P/Q/S AVG/MAXSynchron\0"
        "TC list :TC 1 / TC2 / TC3 / TC4 / TC5 / \0"
        "Tension Alim\0"
        "Tension simple Inject en Calib\0"
        "thd I1\0"
        "thd I2\0"
        "thd I3\0"
        "thd U12\0"
        "thd U23\0"
        "thd U31\0"
        "thd V1\0"
        "thd V2\0"
        "thd V3\0"
        "Total Active Power +/- : P\0"
        "Total apparent power : S\0"
        "Total Negative Active Energy (no resetab\0"
        "Total Positive Active Energy (no resetab\0"
        "Total Reactive Power +/- : Q\0"
        "Vendor name (EX : SOCOMEC)\0"
        "Version logiciel\0"
;

#endif  //  PASTE_GENERATED_NAMES_HERE

#ifndef PASTE_GENERATED_UNITS_HERE

const uint16_t max_unit_length = 12;
const char all_units[] PROGMEM =  //  Generated list of all units based on Modbus table.
    "- / 1000\0"
        "? / 10\0"
        "% / 10\0"
        "A\0"
        "A / 1000\0"
        "h\0"
        "h / 100\0"
        "Hz / 100\0"
        "V / 100\0"
        "VA / 0.1\0"
        "var / 0.1\0"
        "varh / 0.001\0"
        "W / 0.1\0"
        "Wh / 0.001\0"
        "Wh / 1E-06\0"
;

#endif  //  PASTE_GENERATED_UNITS_HERE

String getUnitByIndex(uint16_t unit_index) {
  //  Get the unit from flash memory by index to all_units.
  char buffer[max_unit_length + 1];
  char *s = (char *)(all_units + unit_index);
  strlcpy_P(buffer, s, max_unit_length);
  return String(buffer);
}

String getNameByIndex(uint16_t name_index) {
  //  Get the name from flash memory by index to all_names.
  char buffer[max_name_length + 1];
  char *s = (char *)(all_names + name_index);
  strlcpy_P(buffer, s, max_name_length);
  return String(buffer);
}

boolean checkRegister(Register reg) {
  Serial.println("transmit="); Serial.println(reg.transmit);
  if (!reg.transmit) return false;
  Serial.println("address="); Serial.println(reg.address);
  if (reg.address != 50520) return false;
  Serial.println("size="); Serial.println(reg.size);
  if (reg.size != 2) return false;
  Serial.println("name_index="); Serial.println(reg.name_index);
  String name = getNameByIndex(reg.name_index);
  Serial.println("name="); Serial.println(name);
  if (name != "Simple voltage : V1") return false;
  Serial.println("unit_index="); Serial.println(reg.unit_index);
  String unit = getUnitByIndex(reg.unit_index);
  Serial.println("unit="); Serial.println(unit);
  if (unit != "V / 100") return false;
  Serial.println("type="); Serial.println(reg.type);
  if (reg.type != TYPE_U32) return false;
  return true;
}

void testRegisters() {
  Serial.begin(9600);
  Serial.println("length="); Serial.println(all_registers.rows());
  int i = 0;
  Register reg = {
      (boolean) all_registers[i][0], all_registers[i][1], all_registers[i][2],
      all_registers[i][3], all_registers[i][4], all_registers[i][5],
  };
  if (!checkRegister(reg)) Serial.println("******Test failed");
  else Serial.println("OK");
  for (;;) {}
}

#endif //  REGISTER_H
